{"version":3,"sources":["const.ts","util.ts","App.tsx","serviceWorker.ts","index.tsx"],"names":["AIConfig","DisplayConstraints","QVGA","facingMode","width","exact","height","VGA","HD","FULLHD","FourK","ideal","max","EightK","DisplayConstraintOptions","captureVideoImageToCanvas","video","videoCaptureCanvas","document","createElement","videoWidth","videoHeight","getContext","drawImage","App","state","count","videoResolution","colnum","rownum","showRect","showSS","showGrid","initialized","parentRef","React","createRef","videoRef","controllerCanvasRef","controllerDivRef","workerSSMaskMonitorCanvasRef","parentHeight","parentWidth","overlayWidth","overlayHeight","overlayXOffset","overlayYOffset","scalableSS","ScalableSemanticSegmentation","changeCameraResolution","resolution","current","srcObject","getTracks","map","s","stop","navigator","mediaDevices","getUserMedia","webCamPromise","audio","then","stream","console","log","Promise","resolve","reject","onloadedmetadata","all","res","checkParentSizeChanged","setState","catch","error","requestScanBarcode","a","controller","captureCanvas","remove","window","requestAnimationFrame","predict","this","addInitializedListener","props","addMaskPredictedListeners","maskBitmap","init","getBoundingClientRect","bottom","top","right","left","Math","floor","findOverlayLocation","initWorkerPromise","initWorker","constraintOptions","Object","keys","v","key","text","value","colnumOptions","rownumOptions","style","position","ref","autoPlay","playsInline","muted","Dropdown","options","simple","item","onChange","e","Label","basic","size","color","onClick","newValue","previewCanvas","girdDrawCanvas","Component","Boolean","location","hostname","match","ReactDOM","render","StrictMode","getElementById","serviceWorker","ready","registration","unregister","message"],"mappings":"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","file":"static/js/main.e306d0d3.chunk.js","sourcesContent":["\nexport const AppStatus = {\n    INITIALIZING: \"initializing\",\n    INITIALIZED : \"initialized\",\n    RUNNING     : \"running\",\n}\n\nexport const AIConfig = {\n\n    SPLIT_MARGIN: 0.2,\n    SPLIT_WIDTH: 300,\n    SPLIT_HEIGHT: 300,\n    TRANSFORMED_WIDTH: 300,\n    TRANSFORMED_HEIGHT: 300,\n    TRANSFORMED_MAX: 300,\n    CROP_MARGIN: 20,\n\n    SS_MODEL_PATH: '/WEB_MODEL/300x300_0.10/model.json',\n}\n\n\nexport const WorkerCommand = {\n    SET_OVERLAY  :  'set_overlay',\n    SCAN_BARCODE : 'scan_barcode',\n    PREDICT_AREA : 'predict_area',\n    DRAW_MASK    : 'draw_mask',\n    SCAN_BARCODES: 'scan_barcodes',\n}\n\nexport const WorkerResponse = {\n    NOT_PREPARED     : 'not_prepared',\n    INITIALIZED      : 'initialized',\n    SCANED_BARCODE   : 'scaned_barcode',\n    PREDICTED_AREA   : 'predicted_area',\n    DREW_MASK        : 'drew_mask',\n    SCANNED_BARCODES : 'scanned_barcodes',\n}\n\n/////////////////////////////\n////// ディスプレイ設定  ////\n/////////////////////////////\n\n\nexport const qvgaConstraints:MediaTrackConstraintSet = {\n    facingMode: \"environment\",\n    width: { exact: 320 },\n    height: { exact: 240 }\n};\n\nexport const vgaConstraints:MediaTrackConstraintSet = {\n    facingMode: \"environment\",\n    width: { exact: 640 },\n    height: { exact: 480 }\n};\n\nexport const hdConstraints:MediaTrackConstraintSet = {\n    facingMode: \"environment\",\n    width: { exact: 1280 },\n    height: { exact: 720 }\n};\n\nexport const fullHdConstraints:MediaTrackConstraintSet = {\n    facingMode: \"environment\",\n    width: { exact: 1920 },\n    height: { exact: 1080 }\n};\n\nexport const fourKConstraints:MediaTrackConstraintSet = {\n    facingMode: \"environment\",\n    width: { ideal: 2500, max: 4096 },\n    height: { ideal: 1600, max: 4096 }\n};\n\nexport const eightKConstraints:MediaTrackConstraintSet = {\n    facingMode: \"environment\",\n    width: { ideal: 7680 },\n    height: { ideal: 4320 }\n};\n\n\nexport const DisplayConstraints = {\n    QVGA:   qvgaConstraints,\n    VGA:    vgaConstraints,\n    HD:     hdConstraints,\n    FULLHD: fullHdConstraints,\n    FourK:  fourKConstraints,\n    EightK: eightKConstraints,\n} as const\n\nexport const DisplayConstraintOptions:{[key:string]:MediaTrackConstraintSet} = {\n    \"VGA\"    : DisplayConstraints.VGA,\n    \"HD\"     : DisplayConstraints.HD,\n    \"FULLHD\" : DisplayConstraints.FULLHD\n}\n\nexport const DisplayConstraint   = DisplayConstraints.FULLHD\n//export const DisplayConstraint = DisplayConstraints.HD\n//export const DisplayConstraint = DisplayConstraints.VGA\n","interface OverlayLocation {\n    overlayWidth: number\n    overlayHeight: number\n    overlayXOffset: number\n    overlayYOffset: number\n}\n\nexport function findOverlayLocation(parentWidth:number, parentHeight:number, videoWidth: number, videoHeight: number): OverlayLocation {\n    const parentAspect = parentWidth / parentHeight\n    const videoAspect = videoWidth / videoHeight\n\n    let overlayHeight = 0\n    let overlayWidth = 0\n    let overlayXOffset = 0\n    let overlayYOffset = 0\n\n    if (parentAspect > videoAspect) {\n        //キャンバスのほうが横長　➔　キャンバスの縦で律速\n        // \n        overlayHeight = parentHeight\n        overlayYOffset = 0\n        overlayWidth = overlayHeight * (videoWidth / videoHeight)\n        overlayXOffset = (parentWidth - overlayWidth) / 2\n    } else {\n        //キャンバスのほうが縦長　➔　キャンバスの横で律速\n        overlayWidth = parentWidth\n        overlayXOffset = 0\n        overlayHeight = overlayWidth * (videoHeight / videoWidth)\n        overlayYOffset = (parentHeight - overlayHeight) / 2\n    }\n    overlayWidth   = Math.floor(overlayWidth)\n    overlayHeight  = Math.floor(overlayHeight)\n    overlayXOffset = Math.floor(overlayXOffset)\n    overlayYOffset = Math.floor(overlayYOffset)\n    //console.log('------------', overlayWidth, overlayHeight, overlayXOffset, overlayYOffset)\n    return {  overlayWidth, overlayHeight, overlayXOffset, overlayYOffset }\n\n}\n\nexport const captureVideoImageToCanvas = (video:HTMLVideoElement):HTMLCanvasElement => {\n    const videoCaptureCanvas    = document.createElement(\"canvas\");\n    videoCaptureCanvas.width = video.videoWidth\n    videoCaptureCanvas.height = video.videoHeight\n\n    const tmpCtx                = videoCaptureCanvas.getContext('2d')!\n    tmpCtx.drawImage(video, 0, 0, videoCaptureCanvas.width, videoCaptureCanvas.height);\n    return videoCaptureCanvas\n}","import React from 'react';\nimport './App.css';\nimport { Dropdown, Label } from 'semantic-ui-react'\nimport { DisplayConstraintOptions, AIConfig } from './const';\nimport { findOverlayLocation, captureVideoImageToCanvas } from './util';\nimport { ScalableSemanticSegmentation } from 'scalable-semantic-segmentation-js'\n\ninterface AppState{\n  count: number,\n  videoResolution:string,\n  colnum:number,\n  rownum:number,\n  showRect:boolean,\n  showSS:boolean,\n  showGrid:boolean,\n  initialized: boolean,\n}\n\nclass App extends React.Component {\n  state: AppState = {\n      count: 0,\n      videoResolution: \"VGA\",\n      colnum: 1,\n      rownum: 1,\n      showRect: true,\n      showSS: false,\n      showGrid: false,\n      initialized: false,\n  }\n\n  ////////////////////\n  // HTML Component //\n  ////////////////////\n  parentRef = React.createRef<HTMLDivElement>()\n  videoRef  = React.createRef<HTMLVideoElement>()\n  controllerCanvasRef = React.createRef<HTMLCanvasElement>()\n  controllerDivRef = React.createRef<HTMLDivElement>()\n  workerSSMaskMonitorCanvasRef = React.createRef<HTMLCanvasElement>()\n  ////////////////////\n  // Component Size //\n  ////////////////////\n  videoHeight = 0\n  videoWidth = 0\n  parentHeight = 0\n  parentWidth = 0\n\n  overlayWidth = 0\n  overlayHeight = 0\n  overlayXOffset = 0\n  overlayYOffset = 0\n\n  scalableSS:ScalableSemanticSegmentation = new ScalableSemanticSegmentation()\n\n  /**\n   * ワーカーの初期化\n   */\n  async initWorker() {\n      // SemanticSegmentation 用ワーカー\n      this.scalableSS.addInitializedListener(()=>{\n          const props = this.props as any\n          this.setState({initialized:true})\n          this.requestScanBarcode()\n      })\n      this.scalableSS.addMaskPredictedListeners((maskBitmap:ImageBitmap)=>{\n          // 再キャプチャ\n          this.requestScanBarcode()\n\n      })\n\n      this.scalableSS.init(AIConfig.SS_MODEL_PATH, AIConfig.SPLIT_WIDTH, AIConfig.SPLIT_HEIGHT, AIConfig.SPLIT_MARGIN)\n      return\n  }\n\n  /**\n   * HTMLコンポーネントに位置計算\n   */\n  private checkParentSizeChanged(video: HTMLVideoElement) {\n      // サイズ算出\n      this.videoHeight = video.videoHeight\n      this.videoWidth  = video.videoWidth\n\n      let parentHeight = video.getBoundingClientRect().bottom - video.getBoundingClientRect().top\n      const parentWidth  = video.getBoundingClientRect().right - video.getBoundingClientRect().left\n\n      parentHeight = (parentWidth/this.videoWidth) * this.videoHeight\n\n      this.parentHeight = parentHeight\n      this.parentWidth = parentWidth\n      const { overlayWidth, overlayHeight, overlayXOffset, overlayYOffset } = findOverlayLocation(this.parentWidth, this.parentHeight, this.videoWidth, this.videoHeight)\n      this.overlayWidth = overlayWidth\n      this.overlayHeight = overlayHeight\n      this.overlayXOffset = overlayXOffset\n      this.overlayYOffset = overlayYOffset\n\n\n      this.workerSSMaskMonitorCanvasRef.current!.width  = this.overlayWidth\n      this.workerSSMaskMonitorCanvasRef.current!.height = this.overlayHeight\n      this.controllerCanvasRef.current!.width  = this.overlayWidth\n      this.controllerCanvasRef.current!.height = this.overlayHeight\n  }\n\n  /**\n   * マウント時の処理\n   * モデルのロード、カメラの準備ができたらイベント発行する\n   */\n  componentDidMount() {\n      console.log('Initializing')\n\n      const initWorkerPromise = this.initWorker()\n\n      if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {\n          const webCamPromise = navigator.mediaDevices\n              .getUserMedia({\n                  audio: false,\n                  video: DisplayConstraintOptions[this.state.videoResolution]\n              })\n              .then(stream => {\n                  console.log(this.videoRef)\n                  this.videoRef.current!.srcObject = stream;\n                  return new Promise((resolve, reject) => {\n                      this.videoRef.current!.onloadedmetadata = () => {\n                          resolve();\n                      };\n                  });\n              });\n          \n          Promise.all([initWorkerPromise, webCamPromise])\n              .then((res) => {\n                  console.log('Camera and model ready!')\n              })\n              .catch(error => {\n                  console.error(error);\n              });\n      }           \n  }\n\n  changeCameraResolution = (resolution:string) =>{\n      (this.videoRef.current!.srcObject as MediaStream ).getTracks().map(s=>s.stop())\n      if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {\n          const webCamPromise = navigator.mediaDevices\n              .getUserMedia({\n                  audio: false,\n                  video: DisplayConstraintOptions[resolution]\n              })\n              .then(stream => {\n                  console.log(this.videoRef)\n                  this.videoRef.current!.srcObject = stream;\n                  return new Promise((resolve, reject) => {\n                      this.videoRef.current!.onloadedmetadata = () => {\n                          resolve();\n                      };\n                  });\n              });\n          \n          Promise.all([webCamPromise])\n              .then((res) => {\n                  console.log('Camera and model ready!')\n                  const video = this.videoRef.current!\n                  this.checkParentSizeChanged(video)\n                  this.setState({videoResolution:resolution})\n              })\n              .catch(error => {\n                  console.error(error);\n              });\n      }           \n  }\n\n\n  requestScanBarcode = async () => {\n      console.log('requestScanBarcode')\n      const video = this.videoRef.current!\n      const controller = this.controllerCanvasRef.current!\n      controller.width = this.overlayWidth\n      controller.height = this.overlayHeight\n\n      const captureCanvas = captureVideoImageToCanvas(video)\n      if(captureCanvas.width === 0){\n          captureCanvas.remove()\n          window.requestAnimationFrame(this.requestScanBarcode);\n          return\n      }\n      this.scalableSS.predict(captureCanvas, this.state.colnum, this.state.rownum)\n      captureCanvas.remove()\n  }\n\n\n  render() {\n      const video = this.videoRef.current!\n\n      if(this.state.initialized === true){\n          console.log('initialized')\n          this.checkParentSizeChanged(video)\n      }\n\n      const constraints = Object.keys(DisplayConstraintOptions)\n      const constraintOptions = constraints.map(v =>{\n          return {key:v, text:v, value:v}\n      })\n\n      const colnumOptionList = [1,2,3]\n      const colnumOptions = colnumOptionList.map(v =>{\n          return {key:v, text:v, value:v}\n      })\n      const rownumOptionList = [1,2,3]\n      const rownumOptions = rownumOptionList.map(v =>{\n          return {key:v, text:v, value:v}\n      })\n\n      return (\n          <div style={{ width: \"100%\", height: this.parentHeight, position: \"relative\", top: 0, left: 0, }} ref={this.parentRef} >\n              <video\n                  autoPlay\n                  playsInline\n                  muted\n                  ref={this.videoRef}\n                  //style={{ position: \"absolute\", top: this.overlayYOffset, left: this.overlayXOffset, width:this.overlayWidth, height:this.overlayHeight}}\n                  \n                  style={{ width: \"100%\", height: \"100%\", position: \"absolute\", top: 0, left: 0, }}\n              />\n              <canvas\n                  ref = {this.workerSSMaskMonitorCanvasRef}\n                  style={{ position: \"absolute\", top: this.overlayYOffset, left: this.overlayXOffset, width:this.parentWidth, height:this.parentHeight}}\n              />\n              <canvas\n                  ref={this.controllerCanvasRef}\n                  style={{ position: \"absolute\", top: this.overlayYOffset, left: this.overlayXOffset, width:this.parentWidth, height:this.parentHeight}}\n              />\n\n\n              <div \n                  ref={this.controllerDivRef}\n                  style={{ position: \"absolute\", top: this.overlayYOffset, left: this.overlayXOffset, width:this.parentWidth, height:this.parentHeight}}\n              >\n                  <Dropdown text='Resolution' options={constraintOptions } simple item onChange={(e, { value }) => {\n                      this.changeCameraResolution(value as string)\n                  }}/>\n                  <Dropdown text='col' options={colnumOptions} simple item  onChange={(e, { value }) => {\n                      this.setState({colnum:value as number})\n                  }}/>\n                  <Dropdown text='row' options={rownumOptions} simple item onChange={(e, { value }) => {\n                      this.setState({rownum:value as number})\n                  }}/>\n                  <Label basic size=\"tiny\" color={this.state.showSS?\"red\":\"grey\"} onClick={()=>{\n                      const newValue = !this.state.showSS\n                      this.scalableSS.previewCanvas = newValue ? this.workerSSMaskMonitorCanvasRef.current! : null\n                      this.setState({showSS:newValue})\n                  }}>ss</Label>\n                  <Label basic size=\"tiny\" color={this.state.showGrid?\"red\":\"grey\"} onClick={()=>{\n                      const newValue = !this.state.showGrid\n                      this.scalableSS.girdDrawCanvas = newValue ? this.controllerCanvasRef.current! : null\n                      this.setState({showGrid:!this.state.showGrid})\n                  }}>grid</Label>\n\n              </div>\n          </div>\n\n      )\n  }\n\n}\n\n\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}