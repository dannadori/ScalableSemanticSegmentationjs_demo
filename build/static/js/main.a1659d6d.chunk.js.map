{"version":3,"sources":["const.ts","util.ts","App.tsx","serviceWorker.ts","index.tsx"],"names":["AIConfig","DisplayConstraints","QVGA","facingMode","width","exact","height","VGA","HD","FULLHD","FourK","ideal","max","EightK","DisplayConstraintOptions","captureVideoImageToCanvas","video","videoCaptureCanvas","document","createElement","videoWidth","videoHeight","getContext","drawImage","App","state","count","videoResolution","colnum","rownum","showRect","showSS","showGrid","initialized","parentRef","React","createRef","imageRef1","imageRef2","videoRef","barcodeDisplayCanvasRef","controllerCanvasRef","statusCanvasRef","controllerDivRef","workerSSMaskMonitorCanvasRef","workerAreaCVCanvasRef","parentHeight","parentWidth","overlayWidth","overlayHeight","overlayXOffset","overlayYOffset","scalableSS","ScalableSemanticSegmentation","video_img","working_video_img","frame","fps","frameCountStartTime","Date","getTime","changeCameraResolution","resolution","current","srcObject","getTracks","map","s","stop","navigator","mediaDevices","getUserMedia","webCamPromise","audio","then","stream","console","log","Promise","resolve","reject","onloadedmetadata","all","res","checkParentSizeChanged","setState","catch","error","requestScanBarcode","a","controller","captureCanvas","remove","window","requestAnimationFrame","predict","getImageData","this","thisTime","addInitializedListener","props","addMaskPredictedListeners","maskBitmap","init","getBoundingClientRect","bottom","top","right","left","Math","floor","findOverlayLocation","initWorkerPromise","initWorker","constraintOptions","Object","keys","v","key","text","value","colnumOptions","rownumOptions","style","position","ref","autoPlay","playsInline","muted","Dropdown","options","simple","item","onChange","e","Label","basic","size","color","onClick","newValue","previewCanvas","girdDrawCanvas","Component","Boolean","location","hostname","match","ReactDOM","render","StrictMode","getElementById","serviceWorker","ready","registration","unregister","message"],"mappings":"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","file":"static/js/main.a1659d6d.chunk.js","sourcesContent":["\nexport const AppStatus = {\n    INITIALIZING: \"initializing\",\n    INITIALIZED : \"initialized\",\n    RUNNING     : \"running\",\n}\n\nexport const AIConfig = {\n\n    SPLIT_MARGIN: 0.2,\n    SPLIT_WIDTH: 300,\n    SPLIT_HEIGHT: 300,\n    TRANSFORMED_WIDTH: 300,\n    TRANSFORMED_HEIGHT: 300,\n    TRANSFORMED_MAX: 300,\n    CROP_MARGIN: 20,\n\n    SS_MODEL_PATH: '/WEB_MODEL/300x300_0.10/model.json',\n}\n\n\nexport const WorkerCommand = {\n    SET_OVERLAY  :  'set_overlay',\n    SCAN_BARCODE : 'scan_barcode',\n    PREDICT_AREA : 'predict_area',\n    DRAW_MASK    : 'draw_mask',\n    SCAN_BARCODES: 'scan_barcodes',\n}\n\nexport const WorkerResponse = {\n    NOT_PREPARED     : 'not_prepared',\n    INITIALIZED      : 'initialized',\n    SCANED_BARCODE   : 'scaned_barcode',\n    PREDICTED_AREA   : 'predicted_area',\n    DREW_MASK        : 'drew_mask',\n    SCANNED_BARCODES : 'scanned_barcodes',\n}\n\n/////////////////////////////\n////// ディスプレイ設定  ////\n/////////////////////////////\n\n\nexport const qvgaConstraints:MediaTrackConstraintSet = {\n    facingMode: \"environment\",\n    width: { exact: 320 },\n    height: { exact: 240 }\n};\n\nexport const vgaConstraints:MediaTrackConstraintSet = {\n    facingMode: \"environment\",\n    width: { exact: 640 },\n    height: { exact: 480 }\n};\n\nexport const hdConstraints:MediaTrackConstraintSet = {\n    facingMode: \"environment\",\n    width: { exact: 1280 },\n    height: { exact: 720 }\n};\n\nexport const fullHdConstraints:MediaTrackConstraintSet = {\n    facingMode: \"environment\",\n    width: { exact: 1920 },\n    height: { exact: 1080 }\n};\n\nexport const fourKConstraints:MediaTrackConstraintSet = {\n    facingMode: \"environment\",\n    width: { ideal: 2500, max: 4096 },\n    height: { ideal: 1600, max: 4096 }\n};\n\nexport const eightKConstraints:MediaTrackConstraintSet = {\n    facingMode: \"environment\",\n    width: { ideal: 7680 },\n    height: { ideal: 4320 }\n};\n\n\nexport const DisplayConstraints = {\n    QVGA:   qvgaConstraints,\n    VGA:    vgaConstraints,\n    HD:     hdConstraints,\n    FULLHD: fullHdConstraints,\n    FourK:  fourKConstraints,\n    EightK: eightKConstraints,\n} as const\n\nexport const DisplayConstraintOptions:{[key:string]:MediaTrackConstraintSet} = {\n    \"VGA\"    : DisplayConstraints.VGA,\n    \"HD\"     : DisplayConstraints.HD,\n    \"FULLHD\" : DisplayConstraints.FULLHD\n}\n\nexport const DisplayConstraint   = DisplayConstraints.FULLHD\n//export const DisplayConstraint = DisplayConstraints.HD\n//export const DisplayConstraint = DisplayConstraints.VGA\n","interface OverlayLocation {\n    overlayWidth: number\n    overlayHeight: number\n    overlayXOffset: number\n    overlayYOffset: number\n}\n\nexport function findOverlayLocation(parentWidth:number, parentHeight:number, videoWidth: number, videoHeight: number): OverlayLocation {\n    const parentAspect = parentWidth / parentHeight\n    const videoAspect = videoWidth / videoHeight\n\n    let overlayHeight = 0\n    let overlayWidth = 0\n    let overlayXOffset = 0\n    let overlayYOffset = 0\n\n    if (parentAspect > videoAspect) {\n        //キャンバスのほうが横長　➔　キャンバスの縦で律速\n        // \n        overlayHeight = parentHeight\n        overlayYOffset = 0\n        overlayWidth = overlayHeight * (videoWidth / videoHeight)\n        overlayXOffset = (parentWidth - overlayWidth) / 2\n    } else {\n        //キャンバスのほうが縦長　➔　キャンバスの横で律速\n        overlayWidth = parentWidth\n        overlayXOffset = 0\n        overlayHeight = overlayWidth * (videoHeight / videoWidth)\n        overlayYOffset = (parentHeight - overlayHeight) / 2\n    }\n    overlayWidth   = Math.floor(overlayWidth)\n    overlayHeight  = Math.floor(overlayHeight)\n    overlayXOffset = Math.floor(overlayXOffset)\n    overlayYOffset = Math.floor(overlayYOffset)\n    //console.log('------------', overlayWidth, overlayHeight, overlayXOffset, overlayYOffset)\n    return {  overlayWidth, overlayHeight, overlayXOffset, overlayYOffset }\n\n}\n\nexport const captureVideoImageToCanvas = (video:HTMLVideoElement):HTMLCanvasElement => {\n    const videoCaptureCanvas    = document.createElement(\"canvas\");\n    videoCaptureCanvas.width = video.videoWidth\n    videoCaptureCanvas.height = video.videoHeight\n\n    const tmpCtx                = videoCaptureCanvas.getContext('2d')!\n    tmpCtx.drawImage(video, 0, 0, videoCaptureCanvas.width, videoCaptureCanvas.height);\n    return videoCaptureCanvas\n}","import React from 'react';\nimport './App.css';\nimport { Dropdown, Label } from 'semantic-ui-react'\nimport { DisplayConstraintOptions, AIConfig } from './const';\nimport { findOverlayLocation, captureVideoImageToCanvas } from './util';\nimport { ScalableSemanticSegmentation } from 'scalable-semantic-segmentation-js'\n\ninterface AppState{\n  count: number,\n  videoResolution:string,\n  colnum:number,\n  rownum:number,\n  showRect:boolean,\n  showSS:boolean,\n  showGrid:boolean,\n  initialized: boolean,\n}\n\n\nclass App extends React.Component {\n  state: AppState = {\n      count: 0,\n      videoResolution: \"VGA\",\n      colnum: 1,\n      rownum: 1,\n      showRect: true,\n      showSS: false,\n      showGrid: false,\n      initialized: false,\n  }\n\n\n  ////////////////////\n  // HTML Component //\n  ////////////////////\n  parentRef = React.createRef<HTMLDivElement>()\n  imageRef1 = React.createRef<HTMLImageElement>()\n  imageRef2 = React.createRef<HTMLImageElement>()\n  videoRef  = React.createRef<HTMLVideoElement>()\n  barcodeDisplayCanvasRef = React.createRef<HTMLCanvasElement>()\n  controllerCanvasRef = React.createRef<HTMLCanvasElement>()\n  statusCanvasRef     = React.createRef<HTMLCanvasElement>()\n  controllerDivRef = React.createRef<HTMLDivElement>()\n  workerSSMaskMonitorCanvasRef = React.createRef<HTMLCanvasElement>()\n  workerAreaCVCanvasRef        = React.createRef<HTMLCanvasElement>()\n  ////////////////////\n  // Component Size //\n  ////////////////////\n  videoHeight = 0\n  videoWidth = 0\n  parentHeight = 0\n  parentWidth = 0\n\n  overlayWidth = 0\n  overlayHeight = 0\n  overlayXOffset = 0\n  overlayYOffset = 0\n\n\n\n\n  scalableSS:ScalableSemanticSegmentation = new ScalableSemanticSegmentation()\n\n  private video_img:ImageData|null = null\n  private working_video_img:ImageData|null = null\n  /**\n     * FPS測定用\n     */\n  frame = 0\n  fps   = 0.0\n  frameCountStartTime = new Date().getTime()\n  gameLoop() {\n      this.frame++\n      const thisTime = new Date().getTime()\n      if (thisTime - this.frameCountStartTime > 1000) {\n          const fps = (this.frame / (thisTime - this.frameCountStartTime)) * 1000\n          this.frameCountStartTime = new Date().getTime()\n          this.frame = 0\n          this.fps = fps\n      }\n  }\n\n  /**\n   * ワーカーの初期化\n   */\n  async initWorker() {\n      // SemanticSegmentation 用ワーカー\n      this.scalableSS.addInitializedListener(()=>{\n          const props = this.props as any\n          this.setState({initialized:true})\n          this.requestScanBarcode()\n      })\n      this.scalableSS.addMaskPredictedListeners((maskBitmap:ImageBitmap)=>{\n          // console.log(\"MASK PREDICTED\")\n          this.working_video_img = this.video_img //再キャプチャの前に処理中のimageをバックアップ\n\n          // 再キャプチャ\n          this.requestScanBarcode()\n\n      })\n\n      this.scalableSS.init(AIConfig.SS_MODEL_PATH, AIConfig.SPLIT_WIDTH, AIConfig.SPLIT_HEIGHT, AIConfig.SPLIT_MARGIN)\n      return\n  }\n\n  /**\n   * HTMLコンポーネントに位置計算\n   */\n  private checkParentSizeChanged(video: HTMLVideoElement) {\n      // サイズ算出\n      this.videoHeight = video.videoHeight\n      this.videoWidth  = video.videoWidth\n\n      let parentHeight = video.getBoundingClientRect().bottom - video.getBoundingClientRect().top\n      const parentWidth  = video.getBoundingClientRect().right - video.getBoundingClientRect().left\n\n      parentHeight = (parentWidth/this.videoWidth) * this.videoHeight\n\n      this.parentHeight = parentHeight\n      this.parentWidth = parentWidth\n      const { overlayWidth, overlayHeight, overlayXOffset, overlayYOffset } = findOverlayLocation(this.parentWidth, this.parentHeight, this.videoWidth, this.videoHeight)\n      this.overlayWidth = overlayWidth\n      this.overlayHeight = overlayHeight\n      this.overlayXOffset = overlayXOffset\n      this.overlayYOffset = overlayYOffset\n\n\n      this.workerAreaCVCanvasRef.current!.width  = this.overlayWidth\n      this.workerAreaCVCanvasRef.current!.height = this.overlayHeight\n      this.workerSSMaskMonitorCanvasRef.current!.width  = this.overlayWidth\n      this.workerSSMaskMonitorCanvasRef.current!.height = this.overlayHeight\n      this.controllerCanvasRef.current!.width  = this.overlayWidth\n      this.controllerCanvasRef.current!.height = this.overlayHeight\n  }\n\n  /**\n   * マウント時の処理\n   * モデルのロード、カメラの準備ができたらイベント発行する\n   */\n  componentDidMount() {\n      console.log('Initializing')\n\n      const initWorkerPromise = this.initWorker()\n\n      if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {\n          const webCamPromise = navigator.mediaDevices\n              .getUserMedia({\n                  audio: false,\n                  video: DisplayConstraintOptions[this.state.videoResolution]\n              })\n              .then(stream => {\n                  console.log(this.videoRef)\n                  this.videoRef.current!.srcObject = stream;\n                  return new Promise((resolve, reject) => {\n                      this.videoRef.current!.onloadedmetadata = () => {\n                          resolve();\n                      };\n                  });\n              });\n          \n          Promise.all([initWorkerPromise, webCamPromise])\n              .then((res) => {\n                  console.log('Camera and model ready!')\n              })\n              .catch(error => {\n                  console.error(error);\n              });\n      }           \n  }\n\n  changeCameraResolution = (resolution:string) =>{\n      (this.videoRef.current!.srcObject as MediaStream ).getTracks().map(s=>s.stop())\n      if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {\n          const webCamPromise = navigator.mediaDevices\n              .getUserMedia({\n                  audio: false,\n                  video: DisplayConstraintOptions[resolution]\n              })\n              .then(stream => {\n                  console.log(this.videoRef)\n                  this.videoRef.current!.srcObject = stream;\n                  return new Promise((resolve, reject) => {\n                      this.videoRef.current!.onloadedmetadata = () => {\n                          resolve();\n                      };\n                  });\n              });\n          \n          Promise.all([webCamPromise])\n              .then((res) => {\n                  console.log('Camera and model ready!')\n                  const video = this.videoRef.current!\n                  this.checkParentSizeChanged(video)\n                  this.setState({videoResolution:resolution})\n              })\n              .catch(error => {\n                  console.error(error);\n              });\n      }           \n\n  }\n\n\n  requestScanBarcode = async () => {\n      console.log('requestScanBarcode')\n      const video = this.videoRef.current!\n      const controller = this.controllerCanvasRef.current!\n      controller.width = this.overlayWidth\n      controller.height = this.overlayHeight\n\n      const captureCanvas = captureVideoImageToCanvas(video)\n      if(captureCanvas.width === 0){\n          captureCanvas.remove()\n          window.requestAnimationFrame(this.requestScanBarcode);\n          return\n      }\n      this.scalableSS.predict(captureCanvas, this.state.colnum, this.state.rownum, AIConfig.SPLIT_MARGIN)\n      this.video_img = captureCanvas.getContext(\"2d\")!.getImageData(0, 0, captureCanvas.width, captureCanvas.height)\n      captureCanvas.remove()\n\n  }\n\n\n  render() {\n      const video = this.videoRef.current!\n\n      if(this.state.initialized === true){\n          console.log('initialized')\n          this.checkParentSizeChanged(video)\n      }\n\n      const constraints = Object.keys(DisplayConstraintOptions)\n      const constraintOptions = constraints.map(v =>{\n          return {key:v, text:v, value:v}\n      })\n\n      const colnumOptionList = [1,2,3]\n      const colnumOptions = colnumOptionList.map(v =>{\n          return {key:v, text:v, value:v}\n      })\n      const rownumOptionList = [1,2,3]\n      const rownumOptions = rownumOptionList.map(v =>{\n          return {key:v, text:v, value:v}\n      })\n\n      return (\n          <div style={{ width: \"100%\", height: this.parentHeight, position: \"relative\", top: 0, left: 0, }} ref={this.parentRef} >\n              {/* <img src=\"imgs/barcode01.png\" alt=\"barcode\" ref={this.imageRef1} />\n              <img src=\"imgs/barcode02.png\" alt=\"barcode\" ref={this.imageRef2} /> */}\n              <video\n                  autoPlay\n                  playsInline\n                  muted\n                  ref={this.videoRef}\n                  //style={{ position: \"absolute\", top: this.overlayYOffset, left: this.overlayXOffset, width:this.overlayWidth, height:this.overlayHeight}}\n                  \n                  style={{ width: \"100%\", height: \"100%\", position: \"absolute\", top: 0, left: 0, }}\n              />\n              <canvas\n                  ref = {this.workerSSMaskMonitorCanvasRef}\n                  style={{ position: \"absolute\", top: this.overlayYOffset, left: this.overlayXOffset, width:this.parentWidth, height:this.parentHeight}}\n              />\n              <canvas\n                  ref = {this.workerAreaCVCanvasRef}\n                  style={{ position: \"absolute\", top: this.overlayYOffset, left: this.overlayXOffset, width:this.parentWidth, height:this.parentHeight}}\n              />\n              <canvas\n                  ref={this.barcodeDisplayCanvasRef}\n                  style={{ position: \"absolute\", top: this.overlayYOffset, left: this.overlayXOffset, width:this.parentWidth, height:this.parentHeight}}\n              />\n\n              <canvas\n                  ref={this.controllerCanvasRef}\n                  style={{ position: \"absolute\", top: this.overlayYOffset, left: this.overlayXOffset, width:this.parentWidth, height:this.parentHeight}}\n              />\n\n              <canvas\n                  ref={this.statusCanvasRef}\n                  style={{ position: \"absolute\", top: this.overlayYOffset, left: this.overlayXOffset, width:this.parentWidth, height:this.parentHeight}}\n              />\n\n\n              <div \n                  ref={this.controllerDivRef}\n                  style={{ position: \"absolute\", top: this.overlayYOffset, left: this.overlayXOffset, width:this.parentWidth, height:this.parentHeight}}\n              >\n                  <Dropdown text='Resolution' options={constraintOptions } simple item onChange={(e, { value }) => {\n                      this.changeCameraResolution(value as string)\n                  }}/>\n                  <Dropdown text='col' options={colnumOptions} simple item  onChange={(e, { value }) => {\n                      this.setState({colnum:value as number})\n                  }}/>\n                  <Dropdown text='row' options={rownumOptions} simple item onChange={(e, { value }) => {\n                      this.setState({rownum:value as number})\n                  }}/>\n                  <Label basic size=\"tiny\" color={this.state.showSS?\"red\":\"grey\"} onClick={()=>{\n                      const newValue = !this.state.showSS\n                      // this.workerSSMaskMonitorCanvasRef.current!.width  = this.overlayWidth\n                      // this.workerSSMaskMonitorCanvasRef.current!.height = this.overlayHeight\n                      this.scalableSS.previewCanvas = newValue ? this.workerSSMaskMonitorCanvasRef.current! : null\n                      this.setState({showSS:newValue})\n                  }}>ss</Label>\n                  <Label basic size=\"tiny\" color={this.state.showGrid?\"red\":\"grey\"} onClick={()=>{\n                      const newValue = !this.state.showGrid\n                      // this.controllerCanvasRef.current!.width  = this.overlayWidth\n                      // this.controllerCanvasRef.current!.height = this.overlayHeight\n                      this.scalableSS.girdDrawCanvas = newValue ? this.controllerCanvasRef.current! : null\n                      this.setState({showGrid:!this.state.showGrid})\n                  }}>grid</Label>\n\n              </div>\n          </div>\n\n      )\n  }\n\n}\n\n\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}